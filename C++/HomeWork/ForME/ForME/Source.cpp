
//Инкапсуляция
class A //Класс
{
public: // Открытые данные
	int a, b; //данные открытого интерфейса
	int ReturnSomething(); //метод открытого интерфейса
private: // скрытые данные 
	int Aa, Ab; //скрытые данные
	void Do_Something(); //скрытый метод
};


//------------------------------------------------------------------------------------------------------------------

//Наследование
class A{    //базовый класс
};

class B : public A{    //public наследование
};

class C : protected A{    //protected наследование
};

class Z : private A{    //private наследование
};
//Конструктор и деструктор Наследования
class First // вызываем при вызове Second
{
public:
	First()  { cout << ">>First constructor" << endl; } //Конструктор
	~First() { cout << ">>First destructor" << endl; } //деструктор
};

class Second : public First // вызываем при вызове Third
{
public:
	Second()  { cout << ">Second constructor" << endl; } 
	~Second() { cout << ">Second destructor" << endl; }
};

class Third : public Second
{
public:
	Third()  { cout << "Third constructor" << endl; }
	~Third() { cout << "Third destructor" << endl; }
};

// выполнение кода
Third *th = new Third();
delete th;

// результат вывода
/*
>>First constructor
>Second constructor
Third constructor

Third destructor
>Second destructor
>>First destructor
*/


//------------------------------------------------------------------------------------------------------------------

//Классы
class MyClass : public ParentClass // ParentClass — класс-предок, если таковой имеется
{
public:
	// элементы в этой секции доступны из любой части программы
	MyClass(); // конструктор
	~MyClass(); // деструктор
protected:
	// элементы в этой секции доступны из класса и его потомков
private:
	// элементы в этой секции доступны только из класса; это область доступа по умолчанию
};

После своего создания класс считается полноценным типом данных и, следовательно экземпляры класса создаются следующим образом :

MyClass myinstance;

Обращение к членам класса :

myinstance.classmember



//------------------------------------------------------------------------------------------------------------------


//Объект
// Создание экземпляра класса ArrayList с именем list
ArrayList list = new ArrayList();

// Добавление экземпляров класса Integer в объект list
list.add(new Integer(1));
list.add(new Integer(2));
list.add(new Integer(3));



//------------------------------------------------------------------------------------------------------------------

//Конструктор и Деструктор

//Важно запомнить :
1 конструктор и деструктор, мы всегда объявляем в разделе public;
2 при объявлении конструктора, тип данных возвращаемого значения не указывается, в том числе — void!!!;
3 у деструктора так же нет типа данных для возвращаемого значения, к тому же деструктору нельзя передавать никаких параметров;
4 имя класса и конструктора должно быть идентично;
5 имя деструктора идентично имени конструктора, но с приставкой ~;
6 В классе допустимо создавать несколько конструкторов, если это необходимо.Имена, согласно пункту 2 нашего списка, будут одинаковыми.Компилятор будет их различать по передаваемым параметрам(как при перегрузке функций).Если мы не передаем в конструктор параметры, он считается конструктором по умолчанию;
7 Обратите внимание на то, что в классе может быть объявлен только один деструктор;


# include <iostream>
using namespace std;

class AB //класс
{
private:
	int a;
	int b;
public:
	AB()    //это конструктор:  1) у конструктора нет типа возвращаемого значения! в том числе void!!!
		//   2) имя должно быть таким как и у класса (в нашем случае AB)
	{
		a = 0;//присвоим начальные значения переменным
		b = 0;
		cout << "Работа конструктора при создании нового объекта: " << endl;//и здесь же их отобразим на экран
		cout << "a = " << a << endl;
		cout << "b = " << b << endl << endl;
	}

	void setAB() // с помощью этого метода изменим начальные значения заданные конструктором
	{
		cout << "Введите целое число а: ";
		cin >> a;
		cout << "Введите целое число b: ";
		cin >> b;
	}

	void getAB() //выведем на экран измененные значения
	{
		cout << "a = " << a << endl;
		cout << "b = " << b << endl << endl;
	}
};

int main()
{
	setlocale(LC_ALL, "rus");

	AB obj1;     //конструктор сработает на данном этапе (во время создания объекта класса)

	obj1.setAB();   //присвоим новые значения переменным
	obj1.getAB();   //и выведем их на экран

	AB obj2;     //конструктор сработает на данном этапе (во время создания 2-го объекта класса)
	return 0;
}

//------------------------------------------------------------------------------------------------------------------

//Перегрузка операторов

class Integer
{
private:
	int value;
public:
	Integer(int i) : value(i)
	{}

	//унарный +
	friend const Integer& operator+(const Integer& i);

	//унарный -
	friend const Integer operator-(const Integer& i);

	//префиксный инкремент
	friend const Integer& operator++(Integer& i);

	//постфиксный инкремент
	friend const Integer operator++(Integer& i, int);

	//префиксный декремент
	friend const Integer& operator--(Integer& i);

	//постфиксный декремент
	friend const Integer operator--(Integer& i, int);
};

//унарный плюс ничего не делает.
const Integer& operator+(const Integer& i) {
	return i.value;
}

const Integer operator-(const Integer& i) {
	return Integer(-i.value);
}

//префиксная версия возвращает значение после инкремента
const Integer& operator++(Integer& i) {
	i.value++;
	return i;
}

//постфиксная версия возвращает значение до инкремента
const Integer operator++(Integer& i, int) {
	Integer oldValue(i.value);
	i.value++;
	return oldValue;
}

//префиксная версия возвращает значение после декремента
const Integer& operator--(Integer& i) {
	i.value--;
	return i;
}

//постфиксная версия возвращает значение до декремента
const Integer operator--(Integer& i, int) {
	Integer oldValue(i.value);
	i.value--;
	return oldValue;
}



//------------------------------------------------------------------------------------------------------------------




//Виртуальные функции

// небольшой пример использования виртуальных функций
#include <iostream.h>
class Base {
public:
	virtual void who() { // определение виртуальной функции
		cout << *Base\n";
	}
};
class first_d : public Base {
public:
	void who() { // определение who() применительно к first_d
		cout << "First derivation\n";
	}
};
class seconded : public Base {
public:
	void who() { // определение who() применительно к second_d
		cout << "Second derivation\n*";
	}
};
int main()
{
	Base base_obj;
	Base *p;
	first_d first_obj;
	second_d second_obj;
	p = &base_obj;
	p->who(); // доступ к who класса Base
	p = &first_obj;
	p->who(); // доступ к who класса first_d
	p = &second_ob;
	p->who(); // доступ к who класса second_d
	return 0;
}

Программа выдаст следующий результат :

Base
First derivation
Second derivation





//------------------------------------------------------------------------------------------------------------------

//Структуры




#include <iostream>
using namespace std;

struct building     //Создаем структуру!
{
	char *owner;       //здесь будет храниться имя владельца
	char *city;        //название города
	int amountRooms;   //количество комнат
	float price;       //цена
};

int main()
{
	setlocale(LC_ALL, "rus");

	building apartment1;   //это объект структуры с типом данных, именем структуры, building

	apartment1.owner = "Денис"; //заполняем данные о владельце и т.д.
	apartment1.city = "Симферополь";
	apartment1.amountRooms = 5;
	apartment1.price = 150000;

	cout << "Владелец квартиры: " << apartment1.owner << endl;
	cout << "Квартира находится в городе: " << apartment1.city << endl;
	cout << "Количество комнат: " << apartment1.amountRooms << endl;
	cout << "Стоимость: " << apartment1.price << " $" << endl;

	return 0;
}


//------------------------------------------------------------------------------------------------------------------


//Итератор


ContainerType C; // Любой стандартный тип контейнера, например std::list<sometype>
//for (ContainerType::iterator it = C.begin(),end = C.end(); it != end; ++it) { для изменяемого итератора
//(если вам нужно изменять элементы)
for (ContainerType::const_iterator it = C.begin(), end = C.end(); it != end; ++it) {
	std::cout << *it << std::endl;
}


ContainerType<ItemType> C; // Любой стандартный тип контейнера элементов ItemType
void ProcessItem(const ItemType& I) // Функция, обрабатывающая каждый элемент коллекции
{
	std::cout << I << std::endl;
}

std::for_each(C.begin(), C.end(), ProcessItem); // Цикл просмотра




//------------------------------------------------------------------------------------------------------------------


//статические поля

class foo {
private:
	int x; // Это поле — закрытое. Доступ к нему возможен только
	// из методов класса ''foo''.
public:
	int y; //Это поле — открытое. Доступ к нему возможен из
	//любого места программы. Рекомендуется так не делать.

	// Эти два метода ([[свойство (программирование)#Процедуры свойств|акцессор]]
	// и [[w:en:Mutator method|мутатор]]) обеспечивают доступ к
	// закрытому полю x. Рекомендуется делать именно так.
	int get_x() { return x; };
	void set_x(int x) { this->x = x; };

	static int z; // Это статическое поле. Оно принадлежит классу
	// foo целиком, а не его объектам.

	char a : 3; // Это битовые поля. В сумме они занимают
	char b : 3; // 8 бит, т.е. они будут размещены в одном
	char c : 1; // байте памяти. Таким образом возможно
	char d : 1; // обращаться к отдельным битам памяти.
};




//------------------------------------------------------------------------------------------------------------------


//Метод

// файл реализации класса CppStudio.cpp

#include <iostream>
using namespace std;
// подключаем интерфейс класса к файлу его реализации
#include "CppStudio.h"

CppStudio::CppStudio(int date_day, int date_month, int date_year) // конструктор класса
{
	setDate(date_day, date_month, date_year); // вызов функции установки даты
}

void CppStudio::message() // функция (метод класса) выводящая сообщение на экран
{
	cout << "nwebsite: cppstudio.comntheme: Classes and Objects in C + +n";
}

void CppStudio::setDate(int date_day, int date_month, int date_year) // установка даты в формате дд.мм.гг
{
	day = date_day; // инициализация день
	month = date_month; // инициализация месяц
	year = date_year; // инициализация год
}

void CppStudio::getDate() // отобразить текущую дату
{
	cout << "date: " << day << "." << month << "." << year << endl;
}


//------------------------------------------------------------------------------------------------------------------


//Константы

// инициализирующее выражение обязательно
const int ci1 = 6, ci7 = 7;

// объявление константы определенной в другом модуле
extern const int a;

int func(const char* arg){
	// данные на которые указывает arg
	// нельзя изменить
	...
}


//------------------------------------------------------------------------------------------------------------------

//Алгоритм



for_each, который представляет собой алгоритм обхода по умолчанию. (Также transform для семантики "не вместо".)

find_if, который представляет собой алгоритм поиска по умолчанию.

sort, lower_bound и другие параметры сортировки по умолчанию и алгоритмы поиска.

При создании компаратора по мере возможности используйте строгое неравенство < и именованные лямбда - выражения.
C++

auto comp = [](const widget& w1, const widget& w2)
{ return w1.weight() < w2.weight(); }

sort(v.begin(), v.end(), comp);

auto i = lower_bound(v.begin(), v.end(), comp);

Циклы

Если возможно, используйте циклы for на основе диапазона или вызовы алгоритма, а не написанные вручную циклы.copy, transform, count_if, remove_if и другие подобные им намного лучше, чем рукописные циклы, поскольку их предназначение очевидно и они облегчают написание кода без ошибок.Кроме того, многие алгоритмы STL имеют оптимизации реализации, которые делают их более эффективными.

Вместо старого C++:
C++

for (auto i = strings.begin(); i != strings.end(); ++i) {
	:::
	:: :
}

auto i = v.begin();

for (; i != v.end(); ++i) {
	if (*i > x && *i < y) break;
}

Используйте современный язык C++ следующим образом :
C++

for_each(begin(strings), end(strings), [](string& s) {
	:::
	:: :
});
auto i = find_if(begin(v), end(v), [=](int i) { return i > x && i < y; });

Циклы "for" на основе диапазона

Цикл for на основе диапазона является функцией языка С++11, а не алгоритма STL.Тем не менее он заслуживает упоминания в этой дискуссии о циклах.Основанные на диапазоне циклы for представляют собой расширение ключевого слова for и являются удобным и эффективным способом записи циклов, выполняющих итерацию с диапазоном значений.Контейнеры, строки и массивы STL готовы для циклов for на базе диапазонов.Чтобы включить этот новый синтаксис итераций для пользовательского типа, добавьте следующую поддержку :

Метод begin, возвращающий итератор в начало структуры и метод end, который возвращает итератор в конец структуры.

Поддержка в итераторе этих методов : operator*, operator!= и operator++ (версия префикса).

Эти методы могут представлять собой члены или отдельные функции.



//------------------------------------------------------------------------------------------------------------------


//Итераторы STL

http://ci-plus-plus-snachala.ru/?p=298


//------------------------------------------------------------------------------------------------------------------

//Шаблоны классов

http://cppstudio.com/post/5188/

//------------------------------------------------------------------------------------------------------------------


//элементы функционального программирования
http://habrahabr.ru/post/142351/